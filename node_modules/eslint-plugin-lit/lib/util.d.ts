import * as ESTree from 'estree';
import { Rule } from 'eslint';
export interface BabelDecorator extends ESTree.BaseNode {
    type: 'Decorator';
    expression: ESTree.Expression;
}
export interface BabelProperty extends ESTree.MethodDefinition {
    decorators?: BabelDecorator[];
}
export type DecoratedNode = ESTree.Node & {
    decorators?: BabelDecorator[];
};
/**
 * Returns if the given node is a lit class
 * @param {ESTree.Class} clazz
 * @param {Rule.RuleContext} context
 * @return { boolean }
 */
export declare function isLitClass(clazz: ESTree.Class, context: Rule.RuleContext): boolean;
/**
 * Get the name of a node
 *
 * @param {ESTree.Node} node Node to retrieve name of
 * @return {?string}
 */
export declare function getIdentifierName(node: ESTree.Node): string | undefined;
export interface PropertyMapEntry {
    key: ESTree.Node;
    expr: ESTree.ObjectExpression | null;
    state: boolean;
    attribute: boolean;
    attributeName?: string;
}
/**
 * Extracts property metadata from a given property object
 * @param {ESTree.Node} key Node to extract from
 * @param {ESTree.ObjectExpression} value Node to extract from
 * @return {object}
 */
export declare function extractPropertyEntry(key: ESTree.Node, value: ESTree.ObjectExpression): PropertyMapEntry;
/**
 * Returns the class fields of a class
 * @param {ESTree.Class} node Class to retrieve class fields for
 * @return {ReadonlyMap<string, ESTreeObjectExpression>}
 */
export declare function getClassFields(node: ESTree.Class): ReadonlyMap<string, ESTree.PropertyDefinition>;
/**
 * Get the properties object of an element class
 *
 * @param {ESTree.Class} node Class to retrieve map from
 * @return {ReadonlyMap<string, ESTreeObjectExpression>}
 */
export declare function getPropertyMap(node: ESTree.Class): ReadonlyMap<string, PropertyMapEntry>;
/**
 * Determines if a node has a lit property decorator
 * @param {ESTree.Node} node Node to test
 * @return {boolean}
 */
export declare function hasLitPropertyDecorator(node: ESTree.Node): boolean;
/**
 * Generates a placeholder string for a given quasi
 *
 * @param {ESTree.TaggedTemplateExpression} node Root node
 * @param {ESTree.TemplateElement} quasi Quasi to generate placeholder
 * for
 * @return {string}
 */
export declare function getExpressionPlaceholder(node: ESTree.TaggedTemplateExpression, quasi: ESTree.TemplateElement): string;
/**
 * Tests whether a string is a placeholder or not
 *
 * @param {string} value Value to test
 * @return {boolean}
 */
export declare function isExpressionPlaceholder(value: string): boolean;
/**
 * Converts a template expression into HTML
 *
 * @param {ESTree.TaggedTemplateExpression} node Node to convert
 * @return {string}
 */
export declare function templateExpressionToHtml(node: ESTree.TaggedTemplateExpression): string;
/**
 * Converts a camelCase string to snake_case string
 *
 * @param {string} camelCaseStr String to convert
 * @return {string}
 */
export declare function toSnakeCase(camelCaseStr: string): string;
/**
 * Converts a camelCase string to kebab-case string
 *
 * @param {string} camelCaseStr String to convert
 * @return {string}
 */
export declare function toKebabCase(camelCaseStr: string): string;
/**
 * Retrieves the configured element base class list
 *
 * @param {Rule.RuleContext} context ESLint rule context
 * @return {string[]}
 */
export declare function getElementBaseClasses(context: Rule.RuleContext): Set<string>;
